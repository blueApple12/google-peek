// ===== Durable Object with "previous only" history =====
export class LastDO {
  constructor(state, env) {
    this.state = state;
    this.env = env;
    this.data = { q: "", ts: 0 }; // latest
    this.history = [];            // previous items, newest first
    this.state.blockConcurrencyWhile(async () => {
      this.data = (await this.state.storage.get("last")) || { q: "", ts: 0 };
      this.history = (await this.state.storage.get("history")) || [];
    });
  }

  async fetch(request) {
    const url = new URL(request.url);

    // Save: POST body OR GET /api/save?q=...
    if (url.pathname === "/api/save") {
      let q = "";
      const ct = request.headers.get("content-type") || "";
      if (ct.includes("application/x-www-form-urlencoded")) {
        const body = await request.text();
        const params = new URLSearchParams(body);
        q = (params.get("q") || "").toString();
      } else if (ct.includes("application/json")) {
        const data = await request.json().catch(() => ({}));
        q = (data.q || "").toString();
      } else {
        q = (url.searchParams.get("q") || "").toString();
      }

      const cleaned = (q || "").trim();
      if (!cleaned) return new Response("IGNORED", { headers: { "Cache-Control": "no-store" } });

      const now = Date.now();
      const prev = this.data || { q: "", ts: 0 };

      // push *previous* value into history so current isn't duplicated
      if (prev.q && prev.q !== cleaned) {
        this.history.unshift({ q: prev.q, ts: prev.ts || now });
        const MAX = 50;
        if (this.history.length > MAX) this.history.length = MAX;
        await this.state.storage.put("history", this.history);
      }

      this.data = { q: cleaned, ts: now };
      await this.state.storage.put("last", this.data);
      return new Response("OK", { headers: { "Cache-Control": "no-store" } });
    }

    if (url.pathname === "/api/latest") {
      const etag = `"${this.data.ts || 0}"`;
      const inm = request.headers.get("if-none-match");
      if (inm && inm === etag) return new Response(null, { status: 304, headers: { etag } });
      return new Response(JSON.stringify(this.data), {
        headers: { "content-type": "application/json", "Cache-Control": "no-store", etag },
      });
    }

    if (url.pathname === "/api/history") {
      const limit = Math.max(1, Math.min(200, Number(url.searchParams.get("limit")) || 20));
      const slice = this.history.slice(0, limit);
      return new Response(JSON.stringify({ items: slice }), {
        headers: { "content-type": "application/json", "Cache-Control": "no-store" },
      });
    }

    if (url.pathname === "/api/clear" && request.method === "POST") {
      this.history = [];
      await this.state.storage.put("history", this.history);
      return new Response("CLEARED", { headers: { "Cache-Control": "no-store" } });
    }

    return new Response("Not found", { status: 404 });
  }
}

// ===== Worker: routes + pretty /peek page =====
export default {
  async fetch(request, env) {
    const url = new URL(request.url);

    const cors = {
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Methods": "GET,POST,OPTIONS",
      "Access-Control-Allow-Headers": "content-type, if-none-match",
      "Access-Control-Max-Age": "86400",
      "Cache-Control": "no-store",
    };
    if (request.method === "OPTIONS") {
      return new Response(null, { status: 204, headers: cors });
    }

    if (!env.LAST_DO || !env.LAST_DO.idFromName) {
      return new Response("Durable Object binding 'LAST_DO' missing.", { status: 500, headers: cors });
    }

    const id = env.LAST_DO.idFromName("singleton");
    const stub = env.LAST_DO.get(id);

    // API pass-throughs
    if (
      request.method === "POST" ||
      url.pathname === "/api/save" ||
      url.pathname === "/api/history" ||
      url.pathname === "/api/clear" ||
      url.pathname === "/api/latest" ||
      url.searchParams.has("q")
    ) {
      const req =
        url.pathname === "/api/save" ||
        url.pathname === "/api/history" ||
        url.pathname === "/api/clear" ||
        url.pathname === "/api/latest"
          ? request
          : new Request(new URL("/api/save", url), request);
      const res = await stub.fetch(req);
      return new Response(res.body, { status: res.status, headers: { ...cors, ...Object.fromEntries(res.headers) } });
    }

    // redirect / -> /peek (nice for sharing)
    if (url.pathname === "/") return Response.redirect(new URL("/peek", url), 302);

    // Pretty /peek (clicks go to your FRONT_URL with ?prefill=)
    if (url.pathname === "/peek") {
      const html = `<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Reveal</title>
<style>
:root{--bg:#0f1115;--text:#e3e3e3;--muted:#b9bcbf;--chip:#1a1d24;--chip-b:#2a2e36}
*{box-sizing:border-box}
body{margin:0;background:var(--bg);color:var(--text);
     font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Arial,sans-serif;
     display:flex;align-items:center;justify-content:center;min-height:100vh;padding:24px}
.container{width:min(1100px,92vw);display:flex;flex-direction:column;gap:14px}
.value{font-size:clamp(28px,8vw,64px);font-weight:800;text-align:center;transition:opacity .15s ease;word-break:break-word;margin:0 auto}
.hint{color:var(--muted);text-align:center;font-size:14px}
hr{border:none;border-top:1px solid #222;margin:10px 0}
.history-head{display:flex;align-items:center;justify-content:space-between}
.hlist{display:flex;flex-direction:column;gap:6px;max-height:48vh;overflow:auto;padding-right:6px}
.item{display:flex;justify-content:space-between;gap:10px;padding:8px 10px;background:#12151b;border:1px solid #1d2129;border-radius:10px}
.item .q{font-weight:600;word-break:break-word}
.item .ts{color:var(--muted);font-size:12px;white-space:nowrap}
.btn{appearance:none;border:1px solid #2a2e36;background:#171a1f;color:#e3e3e3;border-radius:10px;padding:6px 10px;font-size:13px;cursor:pointer}
.btn:hover{filter:brightness(1.1)}
a.link{color:inherit;text-decoration:none}
a.link:focus-visible{outline:2px solid #2a79ff;outline-offset:3px;border-radius:8px}
a.link:hover{filter:brightness(1.05)}
</style>
</head>
<body>
  <div class="container">
    <div class="row">
      <div id="val" class="value">…</div>
      <div id="hint" class="hint">Waiting…</div>
    </div>

    <hr/>

    <div class="history-head">
      <div class="hint" style="text-align:left">History</div>
      <div style="text-align:right">
        <button id="refresh" class="btn" title="Refresh history">Refresh</button>
        <button id="clear" class="btn" title="Clear history">Clear</button>
      </div>
    </div>
    <div id="hlist" class="hlist" aria-live="polite"></div>
  </div>

<script>
// Point this to your Google-style FRONT page (GitHub Pages or similar)
const FRONT_URL = "https://your-username.github.io/your-front/"; // <-- change me

let etag=null;
const sleep=ms=>new Promise(r=>setTimeout(r,ms));
function fmt(ts){ try{ return new Date(ts||Date.now()).toLocaleString(); }catch(e){ return String(ts); } }
function esc(s){ return String(s||"").replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;"); }
function frontHref(q){ return FRONT_URL + "?prefill=" + encodeURIComponent(q || ""); }

async function latest(){
  const r=await fetch("/api/latest",{cache:"no-store",headers:etag?{"If-None-Match":etag}:{}})
  if(r.status===304) return null;
  if(!r.ok) throw new Error("bad status");
  etag=r.headers.get("etag")||etag;
  return r.json();
}
async function loadHistory(limit=20){
  const r=await fetch("/api/history?limit="+encodeURIComponent(limit),{cache:"no-store"});
  if(!r.ok) throw new Error("history failed");
  const d=await r.json();
  return Array.isArray(d.items)?d.items:[];
}

function renderCurrent(q, ts){
  const val=document.getElementById("val");
  const hint=document.getElementById("hint");
  val.innerHTML = q ? '<a class="link" href="'+frontHref(q)+'" target="_self">'+esc(q)+'</a>' : "…";
  hint.textContent = "Updated " + fmt(ts);
}
function renderHistory(items){
  const h=document.getElementById("hlist");
  if(!items.length){ h.innerHTML='<div class="hint" style="text-align:center">No history yet</div>'; return; }
  h.innerHTML = items.map(it =>
    '<div class="item">'+
      '<div class="q"><a class="link" href="'+frontHref(it.q)+'" target="_self">'+esc(it.q||"")+'</a></div>'+
      '<div class="ts">'+fmt(it.ts)+'</div>'+
    '</div>'
  ).join("");
}

(async()=>{
  const btnR=document.getElementById("refresh");
  const btnC=document.getElementById("clear");

  loadHistory(20).then(renderHistory).catch(()=>{});
  btnR.addEventListener("click", ()=>loadHistory(20).then(renderHistory).catch(()=>{}));
  btnC.addEventListener("click", async ()=>{
    try{ await fetch("/api/clear",{method:"POST"}); await loadHistory(20).then(renderHistory); }catch(e){}
  });

  let last=""; let delay=700;
  while(true){
    try{
      if(document.hidden){ await sleep(1000); continue; }
      const d=await latest();
      if(d){
        const q=(d.q||"").trim();
        if(q!==last){
          last=q;
          const valEl=document.getElementById("val");
          valEl.style.opacity="0.05";
          await Promise.resolve();
          renderCurrent(q, d.ts);
          valEl.style.opacity="1";
          loadHistory(20).then(renderHistory).catch(()=>{});
        }
      }
      await sleep(delay);
    }catch(e){
      delay=Math.min((delay||700)*2,6000);
      await sleep(delay);
    }
  }
})();
</script>
</body>
</html>`;
      return new Response(html, { headers: { ...cors, "content-type": "text/html; charset=utf-8" } });
    }

    return new Response("OK", { headers: { ...cors, "content-type": "text/plain" } });
  },
};
